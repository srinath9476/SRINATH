/*
 * STM32F0G070rbtx.h
 *
 *  Created on: Jan 25, 2021
 *      Author: lenoo
 */

#ifndef INC_STM32F0G070RBTX_H_
#define INC_STM32F0G070RBTX_H_

#include<stdint.h>
#define  __vo volatile

/*
 * base addresses of Flash and SRAM Memories
 */
#define FLASH_BASEADDR  0x08000000U 	/*last U represent its Unsigned value*/
#define SRAM1_BASEADDR  0x20000000U
										//in STM32G0 is not having SRAM2
										/*ïƒ˜	In STM32F4 Series, SRAM2 is present with 112Kbytes
										SRAM1_base address+112Kbytes=0x20001C00U
										 * */
//#define SRAM2_BASEADDR 0x20001C00U

#define ROM_BASEADDR    0x1FFF0000U   	//System memory address is Known as ROM Memory
#define SRAM    		SRAM1_BASEADDR


/*
 * AHBx and APBx Bus Peripheral Base address Defined below
 */

#define PERIPH_BASE      		0x40000000U
#define APB1PERIPH_BASE         PERIPH_BASE
#define APB2PERIPH_BASE         0x40010000U
#define AHB1PERIPH_BASE			0x40020000U
#define IOPORT_BASE             0x50000000U

/*
 * Base addresses of peripherals which are hanging on IOPORT
 *
 */

// By directly we can define base address for each GPIO, or
//else we can define with offset calculation also as shown below
#define GPIOA_BASEADDR   	(IOPORT_BASE+0x0000)
#define GPIOB_BASEADDR		(IOPORT_BASE+0x0400)
#define GPIOC_BASEADDR		(IOPORT_BASE+0x0800)
#define GPIOD_BASEADDR		(IOPORT_BASE+0x0C00)
#define GPIOE_BASEADDR		(IOPORT_BASE+0x1000)
#define GPIOF_BASEADDR		(IOPORT_BASE+0x1400)


#define RCC_BASEADDR		(AHB1PERIPH_BASE+0x1000)
/*
 * Base addresses of Peripherals which are hanging on APB1 bus
 */
#define I2C1_BASEADDR      		(APB1PERIPH_BASE+0x5400U)
#define I2C2_BASEADDR     	 	(APB1PERIPH_BASE+0x5800U)
#define I2C3_BASEADDR      		(APB1PERIPH_BASE+0x8800U)

#define SPI1_BASEADDR      		(APB2PERIPH_BASE+0x3000U)
#define SPI2_BASEADDR      		(APB1PERIPH_BASE+0x3800U)
#define SPI3_BASEADDR     		(APB1PERIPH_BASE+0x3C00U)

#define USART2_BASEADDR      	(APB1PERIPH_BASE+0x4400U)
#define USART3_BASEADDR      	(APB1PERIPH_BASE+0x4800U)
#define USART4_BASEADDR      	(APB1PERIPH_BASE+0x4C00U)
#define USART5_BASEADDR      	(APB1PERIPH_BASE+0x5000U)

#define SYSCFG_BASEADDR      	(APB1PERIPH_BASE+0x10000U)

/*
 * Base addresses of Peripherals which are hanging on AHB1 bus
 */
#define EXT1_BASEADDR      		(AHB1PERIPH_BASE+0x1800U)
/*
 * Base addresses of Peripherals which are hanging on APB2 bus
 */
#define USART1_BASEADDR      	(APB2PERIPH_BASE+0x400U)
#define USART6_BASEADDR      	(APB2PERIPH_BASE+0x800U)

typedef struct
{									//uint32_t is used from stdint.h file,
    __vo uint32_t MODER;           	//0x00	GPIO port mode register (GPIOx_MODER), __vo is volatile
    __vo uint32_t OTYPER;			//0x04	GPIO port output type register (GPIOx_OTYPER)
    __vo uint32_t OSPEEDR;			//0x08	GPIO port output speed register (GPIOx_OSPEEDR)
    __vo uint32_t PUPDR;			//0x0C	GPIO port pull-up/pull-down register (GPIOx_PUPDR)
    __vo uint32_t IDR;				//0x10	GPIO port input data register (GPIOx_IDR)
    __vo uint32_t ODR;				//0x14	GPIO port output data register (GPIOx_ODR)
    __vo uint32_t BSRR;				//0x18	GPIO port bit set/reset register (GPIOx_BSRR)
    __vo uint32_t LCKR;				//0x1C	GPIO port configuration lock register (GPIOx_LCKR)
    __vo uint32_t AFR[2];				//0x24	GPIO alternate function high register (GPIOx_AFRH)
}GPIO_Regdef_t;

typedef struct
{
	__vo uint32_t ControlR;
	__vo uint32_t ICSCR;
	__vo uint32_t CFGRR;
	__vo uint32_t PLL_GFGRR;
	uint32_t Reserved[2];
	__vo uint32_t CIERR;
	__vo uint32_t CIFRR;
	__vo uint32_t CICRR;
	__vo uint32_t IOPRSTRR;
	__vo uint32_t AHBRSTRR;
	__vo uint32_t APBRSTR1R;
	__vo uint32_t APBRSTR2R;
	__vo uint32_t IOPENRR;
	__vo uint32_t AHBENRR;
	__vo uint32_t APBENR1R;
	__vo uint32_t APBENR2R;
	__vo uint32_t IOPSMENRR;
	__vo uint32_t AHBSMENRR;
	__vo uint32_t APBSMENR1R;
	__vo uint32_t APBSMENR2R;
	__vo uint32_t CCIPRR;
	__vo uint32_t CCCIPR2;
	__vo uint32_t BDCRR;
	__vo uint32_t CSRR;

}RCC_Regdef_t;
/*
 * Peripheral definitions (peripheral base addresses type casted to xxx_RegDef_t )
 */

#define GPIOA 	(GPIO_Regdef_t*)GPIOA_BASEADDR
#define GPIOB 	((GPIO_Regdef_t*)GPIOB_BASEADDR)
#define GPIOC 	((GPIO_Regdef_t*)GPIOC_BASEADDR)
#define GPIOD 	((GPIO_Regdef_t*)GPIOD_BASEADDR)
#define GPIOE 	((GPIO_Regdef_t*)GPIOE_BASEADDR)
#define GPIOF 	((GPIO_Regdef_t*)GPIOF_BASEADDR)

#define RCC ((RCC_Regdef_t *)RCC_BASEADDR)

/*
 * Clock Enable macros for GPIOx Peripherals
 */
#define GPIOA_PCLK_EN() (RCC->IOPENRR |= 1<<0)
#define GPIOB_PCLK_EN() (RCC->IOPENRR |= 1<<1)
#define GPIOC_PCLK_EN() (RCC->IOPENRR |= 1<<2)
#define GPIOD_PCLK_EN() (RCC->IOPENRR |= 1<<3)
#define GPIOE_PCLK_EN() (RCC->IOPENRR |= 1<<4)
#define GPIOF_PCLK_EN() (RCC->IOPENRR |= 1<<5)

/*
 * Clock Enable macros for I2C registers
 *
 */
#define I2C1_PCLK_EN() (RCC->APBENR1R |= 1<<21)
#define I2C2_PCLK_EN() (RCC->APBENR1R |= 1<<22)
#define I2C3_PCLK_EN() (RCC->APBENR1R |= 1<<23)

/*
 * Clock Enable macros for SPI registers
 */
#define SPI1_PCLK_EN() (RCC->APBENR2R |= (1<<12))

#define SPI2_PCLK_EN() (RCC->APBENR1R |= (1<<14))
#define SPI3_PCLK_EN() (RCC->APBENR1R |= (1<<15))

/*
 * Clock Enable macros for USART registers
 */
#define USART1_PCLK_EN() (RCC->APBENR2R|=(1<<14))
#define USART2_PCLK_EN() (RCC->APBENR1R|=(1<<17))
#define USART3_PCLK_EN() (RCC->APBENR1R|=(1<<18))
#define USART4_PCLK_EN() (RCC->APBENR1R|=(1<<19))
#define USART5_PCLK_EN() (RCC->APBENR1R|=(1<<8))
#define USART6_PCLK_EN() (RCC->APBENR1R|=(1<<9)))
/*
 * Clock Enable macros for SYSCFG registers
 */
#define SYSCFG_PCLK_EN() (RCC->APBENR2R|=(1<<0))
/*
 * Clock DISEnable macros for GPIOx registers
 */
#define GPIOA_PCLK_DEN() (RCC->IOPENRR &=~( 1<<0)) //& is used for reset  with negation
#define GPIOB_PCLK_DEN() (RCC->IOPENRR &=~( 1<<1))
#define GPIOC_PCLK_DEN() (RCC->IOPENRR &=~( 1<<2))
#define GPIOD_PCLK_DEN() (RCC->IOPENRR &=~( 1<<3))
#define GPIOE_PCLK_DEN() (RCC->IOPENRR &=~( 1<<4))
#define GPIOF_PCLK_DEN() (RCC->IOPENRR &=~( 1<<5))


/*
 * Clock DISEnable macros for I2C registers
 */
#define I2C1_PCLK_DEN() (RCC->APBENR1R &=~(1<<21))
#define I2C2_PCLK_DEN() (RCC->APBENR1R &=~(1<<22))
#define I2C3_PCLK_DEN() (RCC->APBENR1R &=~(1<<23))
/*
 * Clock DISEnable macros for SPI registers
 */
#define SPI1_PCLK_DEN() (RCC->APBENR2R &=~(1<<12))

#define SPI2_PCLK_DEN() (RCC->APBENR1R &=~(1<<14))
#define SPI3_PCLK_DEN() (RCC->APBENR1R &=~(1<<15))
/*
 * Clock DISEnable macros for  USART registers
 */
#define USART1_PCLK_DEN() (RCC->APBENR2R&=~(1<<14))
#define USART2_PCLK_DEN() (RCC->APBENR1R&=~(1<<17))
#define USART3_PCLK_DEN() (RCC->APBENR1R&=~(1<<18))
#define USART4_PCLK_DEN() (RCC->APBENR1R&=~(1<<19))
#define USART5_PCLK_DEN() (RCC->APBENR1R&=~(1<<8))
#define USART6_PCLK_DEN() (RCC->APBENR1R&=~(1<<9)))
/*
 * Clock DISEnable macros for  SYSCFG registers
 *
 */
#define SYSCFG_PCLK_DEN() (RCC->APBENR2R &=~(1<<0))


/*
 * Reseting the IO Port
 */
#define GPIOA_REG_RESET() do {(RCC->IOPRSTRR |= 1<<0);/*set*/ (RCC->IOPRSTRR &=~(1<<0));/*Reset*/}while(0)
						//while(0) should not have ';, because, calling function statement has ';'
						//do while Condition loop:
						// This is a technique in 'C' programming to execute multiple
						//'C' Statement using single 'C' macros
#define GPIOB_REG_RESET() do {(RCC->IOPRSTRR |= 1<<1);/*set*/ (RCC->IOPRSTRR &=~(1<<1));/*Reset*/}while(0)
#define GPIOC_REG_RESET() do {(RCC->IOPRSTRR |= 1<<2);/*set*/ (RCC->IOPRSTRR &=~(1<<2));/*Reset*/}while(0)
#define GPIOD_REG_RESET() do {(RCC->IOPRSTRR |= 1<<3);/*set*/ (RCC->IOPRSTRR &=~(1<<3));/*Reset*/}while(0)
#define GPIOE_REG_RESET() do {(RCC->IOPRSTRR |= 1<<4);/*set*/ (RCC->IOPRSTRR &=~(1<<4));/*Reset*/}while(0)
#define GPIOF_REG_RESET() do {(RCC->IOPRSTRR |= 1<<5);/*set*/ (RCC->IOPRSTRR &=~(1<<5));/*Reset*/}while(0)



//Generic macros
#define ENABLE 			1
#define DISABLE 		0
#define SET 			ENABLE
#define RESET 			DISABLE
#define GPIO_PIN_SET 	SET
#define GPIO_PIN_RESET 	RESET

#include "STM32F0G070rbtx_GPIO_driver.h"

#endif /* INC_STM32F0G070RBTX_H_ */