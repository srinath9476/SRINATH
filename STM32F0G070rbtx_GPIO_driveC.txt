/*
 * STM32F0G070rbtx_GPIO_driver.c
 *
 *  Created on: Jan 28, 2021
 *      Author: lenoo
 */

#include "stdio.h"
#include "STM32F0G070rbtx_GPIO_driver.h"
#include "stdint.h"
#include "STM32F0G070rbtx.h"
void GPIO_PeriClockControl(GPIO_Regdef_t *pGPIOx,uint8_t EnorDI)
{

	if(EnorDI==ENABLE)
	{

		if(pGPIOx == GPIOA)
		{
			GPIOA_PCLK_EN();
		}else if(pGPIOx == GPIOB)
		{
			GPIOB_PCLK_EN();
		}else if(pGPIOx == GPIOC)
		{
			GPIOC_PCLK_EN();
		}else if(pGPIOx == GPIOD)
		{
			GPIOD_PCLK_EN();
		}else if(pGPIOx == GPIOE)
		{
			GPIOE_PCLK_EN();
		}else if(pGPIOx == GPIOF)
		{
			GPIOF_PCLK_EN();
		}

	}
	else
	{
		if(pGPIOx == GPIOA)
		{
			GPIOA_PCLK_DEN();
		}
		else if(pGPIOx == GPIOB)
		{
			GPIOB_PCLK_DEN();
		}
		else if(pGPIOx == GPIOC)
		{
			GPIOC_PCLK_DEN();
		}
		else if(pGPIOx == GPIOD)
		{
			GPIOD_PCLK_DEN();
		}
		else if(pGPIOx == GPIOE)
		{
			GPIOE_PCLK_DEN();
		}
		else if(pGPIOx == GPIOF)
		{
			GPIOF_PCLK_DEN();
		}

	}
}

void GPIOx_Init(GPIO_Handle_t *pGPIOHandle) // Pointer to handle the structure, so enclosed with one arguments
{
	//1. Configure the mode of GPIO pin
	uint32_t temp=0;// temp . register
	if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode<=GPIO_MODE_ANALOG)
	{
		// This is non interrupt location
		temp=(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode<<(2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
		//2 represents 2 bits, each pin of GPIO carries 2 bit,
		//2*0 =0 so 0th pin
		//2*15=30 so 15th pin
		//30 left shift will be taking place
		pGPIOHandle->pGPIOxBaseAddr->MODER&=~(0x3<<pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
		pGPIOHandle->pGPIOxBaseAddr->MODER|=temp;
		temp=0;
	}
	else
	{
		// these space for interrupt session
	}
	temp=0;
	//2. Configure the Speed

	temp=(pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed<<(2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOxBaseAddr->OSPEEDR&=~(0x3<<pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOHandle->pGPIOxBaseAddr->OSPEEDR|=temp;
	temp=0;
	//3. Configure the pull up and Pull down

	temp=(pGPIOHandle->GPIO_PinConfig.GPIO_PinPupdControl<<(2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOxBaseAddr->PUPDR&=~(0x3<<pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOHandle->pGPIOxBaseAddr->PUPDR|=temp;
		temp=0;
	//4. Output type
	temp=(pGPIOHandle->GPIO_PinConfig.GPIO_PinOPType<<(1*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOxBaseAddr->OTYPER&=~(0x1<<pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);// Clearing Before it is used
	pGPIOHandle->pGPIOxBaseAddr->OTYPER|=temp;
	temp=0;
	//5. alternative functionality
	if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode==GPIO_MODE_ALTFN)
	{
		uint32_t temp1, temp2;

		temp1=pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber/8;
		temp2=pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber%8;
		pGPIOHandle->pGPIOxBaseAddr->AFR[temp1]&=~(0x0F<<(4*temp2));// need to clear 4 bits
		pGPIOHandle->pGPIOxBaseAddr->AFR[temp1]|=pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode<<(4*temp2);

		temp=0;
	}

}
void GPIO_DeInit(GPIO_Regdef_t *pGPIOx)//bringing all relevant GPIO state register to reset value
{
	// Here for reseting not required to reset individual, instead, has RCC_IOPORT reset register
	if(pGPIOx == GPIOA)
	{
		GPIOA_REG_RESET();
	}else if(pGPIOx == GPIOB)
	{
		GPIOB_REG_RESET();
	}else if(pGPIOx == GPIOC)
	{
		GPIOC_REG_RESET();
	}else if(pGPIOx == GPIOD)
	{
		GPIOD_REG_RESET();
	}else if(pGPIOx == GPIOE)
	{
		GPIOE_REG_RESET();
	}else if(pGPIOx == GPIOF)
	{
		GPIOF_PCLK_EN();
	}
}
/*
 * Data Read and Write
 */

uint8_t GPIO_ReadFromInputPin(GPIO_Regdef_t *pGPIOx, uint8_t PinNumber)
{
/*
 *  As name implies needed GPIO base address and pin numbers
 *  and its return type is either 0 or 1, so function return type is
 *  uint8_t instead of void
 */
	uint8_t Value;
			//****need to get bit field corresponding to pin number
			//
	Value=(uint8_t)((pGPIOx->IDR>>PinNumber)&0x00000001);


	return Value;
}
uint16_t GPIO_ReadFromInputPort(GPIO_Regdef_t *pGPIOx)
{
	uint16_t Value;
				//****need to get bit field corresponding to pin number
				//
		Value=(uint16_t)pGPIOx->IDR;
		return Value;
	return 1;
}

void GPIO_WriteToOutPin(GPIO_Regdef_t *pGPIOx, uint8_t PinNumber, uint8_t Value)
{
/*
 * The return type is nothing since it is output,
 * 3rd argument has 0,1, SET or Reset also, so we need to have macros for GPIO_SET
 * or RESET
 * need to return value to Pin number opposit to Input read
 */
	if(Value == GPIO_PIN_SET)
	{
		//write 1 to the output data register at the bit field corresponding Pin number
		pGPIOx->ODR |=(1<<PinNumber);

	}
	else
	{
		pGPIOx->ODR &=~(1<<PinNumber);

		//write 0 to output pin number
	}
}
void GPIO_WriteToOutPort(GPIO_Regdef_t *pGPIOx, uint16_t Value)
{
	pGPIOx->ODR=Value;
}
void GPIO_ToggleOutputPin(GPIO_Regdef_t *pGPIOx, uint8_t PinNumber)
{
/*
 * IRQ Configuration and ISR handling
 */
	pGPIOx->ODR^=(1<<PinNumber);

	/*
	 * or
	 * pGPIOx->ODR^=(1<<PinNumber);
	 */

}
void GPIO_IRQConfig(uint8_t IRQNumber, uint8_t IRQPriority, uint8_t EnorDi)
{
}

void GPIO_IRQHandling(uint8_t PinNumber)
{
}

